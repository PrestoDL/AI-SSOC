- 빌린 책들 : 컴파일러의 이해, 러스트 프로그래밍 공식 가이드, 데카르트의 오류

앞에 두개는 인문학 코너에 있었는데 000(총류)는 다양한 주제와 분야를 아우르는 지식과 원리를 포함한다고 한다.

최소한 자연과학 코너에 있을 줄 알았는데 오히려 <데카르트의 오류>가 자연과학 코너에 있던게 신기했다

인터넷에 없는 지식이 담겨있기도 하다. 책의 깊이를 다시 한번 느낀다.

### "러스트 가이드"같은, 개인 의견이 나오기 힘들법한 주제의 책은 한 권만 읽어도 괜찮을까?



- 컴파일러

프로그래밍 언어를 기계어로 변환해주는 일종의 번역기라고 볼 수 있다. 어셈블리어를 기계어로 바꾸는 번역기는 어셈블러이다.

소스 프로그램을 기계어로 번역(컴파일)하고, 이에 대한 주소 지정, 심볼 해석을 포함해 연결시키는 링커를 통해 라이브러리들을 하나로 묶고 로더를 통해 실행 가능한(메모리에 적재 가능한 상태) 파일을 만든다.

- 어휘 분석

소스 코드를 문법적 의미가 있는 최소 단위인 토큰으로 끊어내는 것. 토큰은 식별자/상수/예약어/연산자/구분자 등으로 분류됨. C에서 int a = 3 + 5;라고 정의한다면, int(예약어) a(식별자) =(연산자) 3(상수) +(연산자) 5(상수)로 분리해낸다. 구분 방법은 토큰의 패턴을 읽는 방식이기에 식별자 규칙 등이 필요하다(첫 자가 숫자여선 안된다 등). 



- 변수명

식별자는 어떤 대상을 유일하게 식별 및 구별할 수 있는 이름이다. 변수는 실행 시간에 저장된 값이 변경될 수 있는 객체이며, 값을 저장할 때 메모리의 특정 위치를 나타낸다.

- 변수 선언

런타임(컴파일된 프로그램이 실행될 때) 때 메모리에 할당한 변수의 데이터 타입에 관한 내용은 메모리에 저장되지 않는다. 메모리 자체만 보고는 그 값이 뭘 뜻하는 것인지 알수 없다는 뜻이고, 컴파일러가 생성한 코드가 변수의 데이터 타입을 알고 있다. 컴파일 시점에서 "해당 메모리 위치에 있는 int 데이터에 접근"하도록 코드가 작성되면 런타임 기준으로 해당 위치부터 4바이트 크기의 데이터를 하나의 integer 데이터로 접근하게 된다.

### 런타임 기준으로는 데이터 타입이 integer이든 뭐든 크게 상관없는 것 같다. 읽어내는 데이터의 크기만 제외하면 해당 데이터의 타입을 알 필요는 없어 보인다. 이걸 어떻게 읽어내는지는 컴파일 시점에서 이미 결정되기 때문에, 애초에 이런 오동작이 발생하지 않도록 코드가 작성되어야 할 것





- 전처리기

프리프로세서라고도 함. 번역기인데 고급언어-고급언어 간의 번역기라고 보면 될듯. 헤더, 매크로, 조건부 컴파일 등.

- 인터프리터

번역과 동시에 실행한 후 결과를 출력한다는 면에서 컴파일 방식과 차이. 컴파일러가 번역기라면 인터프리터는 통역사에 가까운 느낌이다.

컴파일 방식과 인터프리터 방식은 여러모로 차이가 있다. 반복문을 예로 들어보자

컴파일 방식에서의 반복문은 전체 디코딩이 한 번 이루어진 후 실행만 하면 되지만, 인터프리터 방식에서의 반복문은 각 반복 처리마다 디코딩이 필요하다(훨씬 느리다). 하지만 컴파일 방식은 몇 줄의 소스 프로그램이 수백 줄의 기계어로 번역될 수 있어 큰 메모리를 필요로 함에 반해, 인터프리터 방식은 한 줄 단위로 번역과 실행을 하기에 매번 같은 메모리를 사용한다(메모리 사용을 줄일 수 있다).

### 어째 Astar 알고리즘과 Dstar(Dynamic Astar) 알고리즘을 비교하는 느낌이다. Astar는 현재 map에 대한 정보(wall, start, goal)를 모두 알고 있는 상태에서 시작해 효율적으로 최적의 루트를 찾는 반면, Dstar는 직접 가보지 않은 영역의 map 정보는 알 수 없어 즉각적인 길찾기를 필요로 하지만 map의 변화 등에 유연하게 대처 가능하다는 차이점이 있다.

### 추가로, 인터프리터의 처리 과정은 마치 OS의 프로세스 처리 과정을 보는 것 같다 (명령어를 fetch, decode, release하고 다음 명령어를 받는다). 그런데 OS를 만드는 데에는 성능, 효율성, 안정성, 낮은 단계 언어의 필요성의 문제로 컴파일 방식의 언어를 선호하는 것이 아이러니하다. OS도 프로세스의 일종이지만 성능 대비 유연성을 크게 필요로 하지 않아서인 것 같다.

컴파일 방식과 인터프리터 방식은 언어의 특징이라고 보기에는 어렵다. 컴파일 언어인 C도 인터프리터 방식으로 실행이 가능하고, 인터프리터 언어인 python도 컴파일이 가능하다. 단지 원래 어떤 방식으로 실행했을 때 유리하도록 설계되어 있을 뿐이다

- JIT

Just-In-Time 컴파일. 컴파일과 인터프리터 사이 어딘가에 있는 느낌이다. 인터프리터처럼 코드를 한 줄씩 읽어내지만, 해당 코드를 실행 중에 바로 컴파일하고 많이 쓰이는 코드는 추가 컴파일 없이 재사용한다. 인터프리터의 유연성을 일부 가진 컴파일 방식인 것 같다.













